// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package postgres

import (
	"context"
	"database/sql"
	"time"
)

const appendLog = `-- name: AppendLog :exec
INSERT INTO log_entries (run_id, timestamp, stream, data)
VALUES ($1, $2, $3, $4)
`

type AppendLogParams struct {
	RunID     string    `json:"run_id"`
	Timestamp time.Time `json:"timestamp"`
	Stream    string    `json:"stream"`
	Data      string    `json:"data"`
}

func (q *Queries) AppendLog(ctx context.Context, arg AppendLogParams) error {
	_, err := q.db.ExecContext(ctx, appendLog,
		arg.RunID,
		arg.Timestamp,
		arg.Stream,
		arg.Data,
	)
	return err
}

const createRepo = `-- name: CreateRepo :exec
INSERT INTO repos (id, owner, name, clone_url)
VALUES ($1, $2, $3, $4)
`

type CreateRepoParams struct {
	ID       string `json:"id"`
	Owner    string `json:"owner"`
	Name     string `json:"name"`
	CloneUrl string `json:"clone_url"`
}

func (q *Queries) CreateRepo(ctx context.Context, arg CreateRepoParams) error {
	_, err := q.db.ExecContext(ctx, createRepo,
		arg.ID,
		arg.Owner,
		arg.Name,
		arg.CloneUrl,
	)
	return err
}

const createRun = `-- name: CreateRun :exec
INSERT INTO runs (id, status, started_at, finished_at, exit_code, ui_token, git_link, repo_id, commit_message, author, branch)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
`

type CreateRunParams struct {
	ID            string        `json:"id"`
	Status        string        `json:"status"`
	StartedAt     time.Time     `json:"started_at"`
	FinishedAt    sql.NullTime  `json:"finished_at"`
	ExitCode      sql.NullInt32 `json:"exit_code"`
	UiToken       string        `json:"ui_token"`
	GitLink       string        `json:"git_link"`
	RepoID        string        `json:"repo_id"`
	CommitMessage string        `json:"commit_message"`
	Author        string        `json:"author"`
	Branch        string        `json:"branch"`
}

func (q *Queries) CreateRun(ctx context.Context, arg CreateRunParams) error {
	_, err := q.db.ExecContext(ctx, createRun,
		arg.ID,
		arg.Status,
		arg.StartedAt,
		arg.FinishedAt,
		arg.ExitCode,
		arg.UiToken,
		arg.GitLink,
		arg.RepoID,
		arg.CommitMessage,
		arg.Author,
		arg.Branch,
	)
	return err
}

const getLogs = `-- name: GetLogs :many
SELECT timestamp, stream, data
FROM log_entries
WHERE run_id = $1
ORDER BY id ASC
`

type GetLogsRow struct {
	Timestamp time.Time `json:"timestamp"`
	Stream    string    `json:"stream"`
	Data      string    `json:"data"`
}

func (q *Queries) GetLogs(ctx context.Context, runID string) ([]GetLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLogs, runID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLogsRow{}
	for rows.Next() {
		var i GetLogsRow
		if err := rows.Scan(&i.Timestamp, &i.Stream, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepo = `-- name: GetRepo :one
SELECT id, owner, name, clone_url
FROM repos
WHERE clone_url = $1
`

func (q *Queries) GetRepo(ctx context.Context, cloneUrl string) (Repo, error) {
	row := q.db.QueryRowContext(ctx, getRepo, cloneUrl)
	var i Repo
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Name,
		&i.CloneUrl,
	)
	return i, err
}

const getRun = `-- name: GetRun :one
SELECT r.id, r.status, r.started_at, r.finished_at, r.exit_code, r.ui_token, r.git_link, r.repo_id, r.commit_message, r.author, r.branch,
       re.clone_url, re.owner, re.name as repo_name
FROM runs r
JOIN repos re ON r.repo_id = re.id
WHERE r.id = $1
`

type GetRunRow struct {
	ID            string        `json:"id"`
	Status        string        `json:"status"`
	StartedAt     time.Time     `json:"started_at"`
	FinishedAt    sql.NullTime  `json:"finished_at"`
	ExitCode      sql.NullInt32 `json:"exit_code"`
	UiToken       string        `json:"ui_token"`
	GitLink       string        `json:"git_link"`
	RepoID        string        `json:"repo_id"`
	CommitMessage string        `json:"commit_message"`
	Author        string        `json:"author"`
	Branch        string        `json:"branch"`
	CloneUrl      string        `json:"clone_url"`
	Owner         string        `json:"owner"`
	RepoName      string        `json:"repo_name"`
}

func (q *Queries) GetRun(ctx context.Context, id string) (GetRunRow, error) {
	row := q.db.QueryRowContext(ctx, getRun, id)
	var i GetRunRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ExitCode,
		&i.UiToken,
		&i.GitLink,
		&i.RepoID,
		&i.CommitMessage,
		&i.Author,
		&i.Branch,
		&i.CloneUrl,
		&i.Owner,
		&i.RepoName,
	)
	return i, err
}

const listRuns = `-- name: ListRuns :many
SELECT r.id, r.status, r.started_at, r.finished_at, r.exit_code, r.ui_token, r.git_link, r.repo_id, r.commit_message, r.author, r.branch,
       re.clone_url, re.owner, re.name as repo_name
FROM runs r
JOIN repos re ON r.repo_id = re.id
ORDER BY r.started_at DESC
`

type ListRunsRow struct {
	ID            string        `json:"id"`
	Status        string        `json:"status"`
	StartedAt     time.Time     `json:"started_at"`
	FinishedAt    sql.NullTime  `json:"finished_at"`
	ExitCode      sql.NullInt32 `json:"exit_code"`
	UiToken       string        `json:"ui_token"`
	GitLink       string        `json:"git_link"`
	RepoID        string        `json:"repo_id"`
	CommitMessage string        `json:"commit_message"`
	Author        string        `json:"author"`
	Branch        string        `json:"branch"`
	CloneUrl      string        `json:"clone_url"`
	Owner         string        `json:"owner"`
	RepoName      string        `json:"repo_name"`
}

func (q *Queries) ListRuns(ctx context.Context) ([]ListRunsRow, error) {
	rows, err := q.db.QueryContext(ctx, listRuns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRunsRow{}
	for rows.Next() {
		var i ListRunsRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.StartedAt,
			&i.FinishedAt,
			&i.ExitCode,
			&i.UiToken,
			&i.GitLink,
			&i.RepoID,
			&i.CommitMessage,
			&i.Author,
			&i.Branch,
			&i.CloneUrl,
			&i.Owner,
			&i.RepoName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRunStatus = `-- name: UpdateRunStatus :exec
UPDATE runs
SET status = $2, exit_code = $3, finished_at = $4, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateRunStatusParams struct {
	ID         string        `json:"id"`
	Status     string        `json:"status"`
	ExitCode   sql.NullInt32 `json:"exit_code"`
	FinishedAt sql.NullTime  `json:"finished_at"`
}

func (q *Queries) UpdateRunStatus(ctx context.Context, arg UpdateRunStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateRunStatus,
		arg.ID,
		arg.Status,
		arg.ExitCode,
		arg.FinishedAt,
	)
	return err
}
